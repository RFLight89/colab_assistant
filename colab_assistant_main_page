{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "sYTbse5YZw4m"
      },
      "outputs": [],
      "source": [
        "#УСТАНОВКА ЗАВИСИМОСТЕЙ\n",
        "\n",
        "!pip install -q openai gradio tiktoken langchain langchain-openai langchain-community chromadb"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "mFgURbe_cI6i"
      },
      "outputs": [],
      "source": [
        "# ИМПОРТЫ\n",
        "\n",
        "import os\n",
        "import shutil\n",
        "import ast\n",
        "import json\n",
        "import logging\n",
        "import pandas as pd\n",
        "import gradio as gr\n",
        "import tiktoken\n",
        "from typing import List, Dict, Any, Optional, Tuple\n",
        "from datetime import datetime\n",
        "from io import StringIO\n",
        "\n",
        "#Google Colab\n",
        "from google.colab import auth, drive, files\n",
        "from googleapiclient.discovery import build\n",
        "from googleapiclient.errors import HttpError\n",
        "\n",
        "#LangChain\n",
        "from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n",
        "from langchain.vectorstores import Chroma\n",
        "from langchain.text_splitter import RecursiveCharacterTextSplitter\n",
        "from langchain.chains import RetrievalQA\n",
        "from langchain.schema import Document"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "dIt9YL2ESf8d"
      },
      "outputs": [],
      "source": [
        "# НАСТРОЙКА ЛОГИРОВАНИЯ\n",
        "\n",
        "class LogHandler:\n",
        "    \"\"\"Обработчик логов для отображения в интерфейсе\"\"\"\n",
        "\n",
        "    def __init__(self):\n",
        "        self.logs = []\n",
        "        self.setup_logging()\n",
        "\n",
        "    def setup_logging(self):\n",
        "        \"\"\"Настройка системы логирования\"\"\"\n",
        "        logging.basicConfig(\n",
        "            level=logging.INFO,\n",
        "            format='%(asctime)s - %(levelname)s - %(message)s',\n",
        "            handlers=[logging.StreamHandler()]\n",
        "        )\n",
        "        self.logger = logging.getLogger(__name__)\n",
        "\n",
        "    def log(self, message: str, level: str = \"INFO\"):\n",
        "        \"\"\"Добавление лога\"\"\"\n",
        "        timestamp = datetime.now().strftime(\"%H:%M:%S\")\n",
        "        log_entry = f\"[{timestamp}] {level}: {message}\"\n",
        "        self.logs.append(log_entry)\n",
        "\n",
        "        if level == \"ERROR\":\n",
        "            self.logger.error(message)\n",
        "        elif level == \"WARNING\":\n",
        "            self.logger.warning(message)\n",
        "        else:\n",
        "            self.logger.info(message)\n",
        "\n",
        "    def get_logs(self) -> str:\n",
        "        \"\"\"Получение всех логов\"\"\"\n",
        "        return \"\\n\".join(self.logs[-50:])  # Последние 50 записей\n",
        "\n",
        "    def clear_logs(self):\n",
        "        \"\"\"Очистка логов\"\"\"\n",
        "        self.logs.clear()\n",
        "\n",
        "# МОДУЛЬ РАБОТЫ С GOOGLE COLAB API\n",
        "\n",
        "class ColabNotebookManager:\n",
        "    \"\"\"Менеджер для работы с ноутбуками Google Colab\"\"\"\n",
        "\n",
        "    def __init__(self, log_handler: LogHandler):\n",
        "        self.log_handler = log_handler\n",
        "        self.service = None\n",
        "        self.user_email = None\n",
        "\n",
        "    def authenticate(self) -> bool:\n",
        "        \"\"\"Аутентификация в Google API\"\"\"\n",
        "        try:\n",
        "            self.log_handler.log(\"Начало аутентификации в Google API\")\n",
        "            auth.authenticate_user()\n",
        "            self.service = build('drive', 'v3')\n",
        "\n",
        "            # Получаем email пользователя\n",
        "            about = self.service.about().get(fields='user').execute()\n",
        "            self.user_email = about['user']['emailAddress']\n",
        "\n",
        "            self.log_handler.log(f\"Аутентификация успешна. Пользователь: {self.user_email}\")\n",
        "            return True\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка аутентификации: {str(e)}\", \"ERROR\")\n",
        "            return False\n",
        "\n",
        "    def get_notebooks(self) -> List[Dict[str, Any]]:\n",
        "        \"\"\"Получение списка ноутбуков пользователя\"\"\"\n",
        "        try:\n",
        "            self.log_handler.log(\"Поиск ноутбуков пользователя\")\n",
        "\n",
        "            query = \"(mimeType='application/vnd.google.colaboratory' or mimeType='application/x-ipynb+json')\"\n",
        "            results = self.service.files().list(\n",
        "                q=query,\n",
        "                fields=\"files(id, name, webViewLink, owners)\"\n",
        "            ).execute()\n",
        "\n",
        "            notebooks = []\n",
        "            for file in results.get('files', []):\n",
        "                # Фильтрация untitled и не принадлежащих пользователю\n",
        "                if 'untitled' in file['name'].lower():\n",
        "                    continue\n",
        "\n",
        "                # Проверка владельца\n",
        "                is_owner = any(\n",
        "                    owner.get('emailAddress') == self.user_email\n",
        "                    for owner in file.get('owners', [])\n",
        "                )\n",
        "\n",
        "                if is_owner:\n",
        "                    notebooks.append({\n",
        "                        'id': file['id'],\n",
        "                        'name': file['name'],\n",
        "                        'link': file['webViewLink']\n",
        "                    })\n",
        "\n",
        "            self.log_handler.log(f\"Найдено {len(notebooks)} подходящих ноутбуков\")\n",
        "            return notebooks\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка получения ноутбуков: {str(e)}\", \"ERROR\")\n",
        "            return []\n",
        "\n",
        "\n",
        "    def get_notebook_content(self, notebook_id: str) -> Optional[Dict]:\n",
        "        \"\"\"Получение содержимого ноутбука в формате JSON\"\"\"\n",
        "        try:\n",
        "            self.log_handler.log(f\"Загрузка содержимого ноутбука {notebook_id}\")\n",
        "\n",
        "            file_metadata = self.service.files().get(fileId=notebook_id, fields='mimeType').execute()\n",
        "            mime_type = file_metadata.get('mimeType')\n",
        "\n",
        "            if mime_type == 'application/vnd.google.colaboratory':\n",
        "                # Попытка экспорта Colab файла\n",
        "                try:\n",
        "                    content = self.service.files().export(\n",
        "                        fileId=notebook_id,\n",
        "                        mimeType='application/x-ipynb+json'\n",
        "                    ).execute()\n",
        "                    return json.loads(content.decode('utf-8'))\n",
        "                except HttpError as export_error:\n",
        "                    if export_error.resp.status == 403:\n",
        "                        # Если экспорт недоступен, пытаемся скачать как обычный файл\n",
        "                        self.log_handler.log(f\"Экспорт недоступен для {notebook_id}, пытаемся альтернативный способ\", \"WARNING\")\n",
        "                        try:\n",
        "                            content = self.service.files().get_media(fileId=notebook_id).execute()\n",
        "                            return json.loads(content.decode('utf-8'))\n",
        "                        except:\n",
        "                            # Последняя попытка - создать копию и экспортировать её\n",
        "                            self.log_handler.log(f\"Создаем временную копию файла {notebook_id}\", \"INFO\")\n",
        "                            copy_metadata = {'name': f'temp_copy_{notebook_id}'}\n",
        "                            copied_file = self.service.files().copy(\n",
        "                                fileId=notebook_id,\n",
        "                                body=copy_metadata\n",
        "                            ).execute()\n",
        "\n",
        "                            try:\n",
        "                                content = self.service.files().export(\n",
        "                                    fileId=copied_file['id'],\n",
        "                                    mimeType='application/x-ipynb+json'\n",
        "                                ).execute()\n",
        "\n",
        "                                # Удаляем временную копию\n",
        "                                self.service.files().delete(fileId=copied_file['id']).execute()\n",
        "\n",
        "                                return json.loads(content.decode('utf-8'))\n",
        "                            except:\n",
        "                                # Удаляем временную копию в случае ошибки\n",
        "                                self.service.files().delete(fileId=copied_file['id']).execute()\n",
        "                                raise\n",
        "                    else:\n",
        "                        raise export_error\n",
        "            else:\n",
        "                # Для обычных .ipynb файлов\n",
        "                content = self.service.files().get_media(fileId=notebook_id).execute()\n",
        "                return json.loads(content.decode('utf-8'))\n",
        "\n",
        "        except HttpError as e:\n",
        "            if e.resp.status == 403:\n",
        "                self.log_handler.log(f\"Нет доступа к ноутбуку {notebook_id}, пропускаем\", \"WARNING\")\n",
        "            else:\n",
        "                self.log_handler.log(f\"HTTP ошибка загрузки ноутбука {notebook_id}: {str(e)}\", \"ERROR\")\n",
        "            return None\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка загрузки ноутбука {notebook_id}: {str(e)}\", \"ERROR\")\n",
        "            return None\n",
        "\n",
        "# МОДУЛЬ АНАЛИЗА КОДА\n",
        "\n",
        "class CodeAnalyzer:\n",
        "    \"\"\"Анализатор кода Python\"\"\"\n",
        "\n",
        "    def __init__(self, log_handler: LogHandler):\n",
        "        self.log_handler = log_handler\n",
        "\n",
        "    def extract_imports(self, code: str) -> List[str]:\n",
        "        \"\"\"Извлечение импортов из кода\"\"\"\n",
        "        try:\n",
        "            tree = ast.parse(code)\n",
        "            imports = []\n",
        "\n",
        "            for node in ast.walk(tree):\n",
        "                if isinstance(node, ast.Import):\n",
        "                    for alias in node.names:\n",
        "                        imports.append(alias.name)\n",
        "                elif isinstance(node, ast.ImportFrom):\n",
        "                    module = node.module or ''\n",
        "                    for alias in node.names:\n",
        "                        imports.append(f\"{module}.{alias.name}\" if module else alias.name)\n",
        "\n",
        "            return list(set(imports))\n",
        "\n",
        "        except SyntaxError:\n",
        "            return []\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка анализа импортов: {str(e)}\", \"WARNING\")\n",
        "            return []\n",
        "\n",
        "    def extract_functions_and_classes(self, code: str) -> Dict[str, List[Dict]]:\n",
        "        \"\"\"Извлечение функций и классов из кода\"\"\"\n",
        "        try:\n",
        "            tree = ast.parse(code)\n",
        "            functions = []\n",
        "            classes = []\n",
        "\n",
        "            # Сначала найдем все классы для проверки вложенности\n",
        "            class_nodes = [node for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n",
        "\n",
        "            for node in ast.walk(tree):\n",
        "                if isinstance(node, ast.FunctionDef):\n",
        "                    # Проверяем, что функция не внутри класса\n",
        "                    is_inside_class = False\n",
        "                    for class_node in class_nodes:\n",
        "                        if node in class_node.body:\n",
        "                            is_inside_class = True\n",
        "                            break\n",
        "\n",
        "                    if not is_inside_class:\n",
        "                        try:\n",
        "                            functions.append({\n",
        "                                'name': node.name,\n",
        "                                'code': ast.unparse(node) if hasattr(ast, 'unparse') else f\"def {node.name}(...): ...\",\n",
        "                                'type': 'function'\n",
        "                            })\n",
        "                        except:\n",
        "                            functions.append({\n",
        "                                'name': node.name,\n",
        "                                'code': f\"def {node.name}(...): ...\",\n",
        "                                'type': 'function'\n",
        "                            })\n",
        "\n",
        "                elif isinstance(node, ast.ClassDef):\n",
        "                    methods = []\n",
        "                    for item in node.body:\n",
        "                        if isinstance(item, ast.FunctionDef):\n",
        "                            try:\n",
        "                                methods.append({\n",
        "                                    'name': item.name,\n",
        "                                    'code': ast.unparse(item) if hasattr(ast, 'unparse') else f\"def {item.name}(...): ...\",\n",
        "                                    'type': 'method'\n",
        "                                })\n",
        "                            except:\n",
        "                                methods.append({\n",
        "                                    'name': item.name,\n",
        "                                    'code': f\"def {item.name}(...): ...\",\n",
        "                                    'type': 'method'\n",
        "                                })\n",
        "\n",
        "                    try:\n",
        "                        class_code = ast.unparse(node) if hasattr(ast, 'unparse') else f\"class {node.name}: ...\"\n",
        "                    except:\n",
        "                        class_code = f\"class {node.name}: ...\"\n",
        "\n",
        "                    classes.append({\n",
        "                        'name': node.name,\n",
        "                        'code': class_code,\n",
        "                        'methods': methods,\n",
        "                        'type': 'class'\n",
        "                    })\n",
        "\n",
        "            return {'functions': functions, 'classes': classes}\n",
        "\n",
        "        except SyntaxError:\n",
        "            return {'functions': [], 'classes': []}\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка анализа функций и классов: {str(e)}\", \"WARNING\")\n",
        "            return {'functions': [], 'classes': []}\n",
        "\n",
        "# МОДУЛЬ ОБРАБОТКИ НОУТБУКОВ\n",
        "\n",
        "class NotebookProcessor:\n",
        "    \"\"\"Процессор для анализа ноутбуков\"\"\"\n",
        "\n",
        "    def __init__(self, log_handler: LogHandler):\n",
        "        self.log_handler = log_handler\n",
        "        self.code_analyzer = CodeAnalyzer(log_handler)\n",
        "\n",
        "    def extract_headers(self, cells: List[Dict]) -> List[str]:\n",
        "        \"\"\"Извлечение заголовков из ячеек markdown\"\"\"\n",
        "        headers = []\n",
        "\n",
        "        for cell in cells:\n",
        "            if cell.get('cell_type') == 'markdown':\n",
        "                source = ''.join(cell.get('source', []))\n",
        "                lines = source.split('\\n')\n",
        "\n",
        "                for line in lines:\n",
        "                    line = line.strip()\n",
        "                    if line.startswith('#'):\n",
        "                        # Очистка заголовка от лишних символов\n",
        "                        header = line.lstrip('#').strip()\n",
        "                        if header:\n",
        "                            headers.append(header)\n",
        "\n",
        "        return headers\n",
        "\n",
        "    def extract_conclusion(self, cells: List[Dict]) -> str:\n",
        "        \"\"\"Извлечение текста после заголовка 'Итог'\"\"\"\n",
        "        conclusion_found = False\n",
        "        conclusion_text = []\n",
        "\n",
        "        for cell in cells:\n",
        "            if cell.get('cell_type') == 'markdown':\n",
        "                source = ''.join(cell.get('source', []))\n",
        "                lines = source.split('\\n')\n",
        "\n",
        "                for line in lines:\n",
        "                    line_clean = line.strip().lower()\n",
        "                    if line_clean.startswith('#') and 'итог' in line_clean:\n",
        "                        conclusion_found = True\n",
        "                        continue\n",
        "\n",
        "                    if conclusion_found:\n",
        "                        if line.strip().startswith('#'):\n",
        "                            # Новый заголовок - прекращаем сбор\n",
        "                            break\n",
        "                        conclusion_text.append(line)\n",
        "\n",
        "        result = '\\n'.join(conclusion_text).strip()\n",
        "        return result if result else \"Нет итога\"\n",
        "\n",
        "    def extract_code_elements(self, cells: List[Dict]) -> Tuple[List[str], Dict]:\n",
        "        \"\"\"Извлечение импортов, функций и классов из кода\"\"\"\n",
        "        all_imports = []\n",
        "        all_code_elements = {'functions': [], 'classes': []}\n",
        "\n",
        "        for cell in cells:\n",
        "            if cell.get('cell_type') == 'code':\n",
        "                source = ''.join(cell.get('source', []))\n",
        "\n",
        "                # Очистка от магических команд\n",
        "                lines = source.split('\\n')\n",
        "                clean_lines = []\n",
        "                for line in lines:\n",
        "                    if not line.strip().startswith(('!', '%', '?')):\n",
        "                        clean_lines.append(line)\n",
        "\n",
        "                clean_code = '\\n'.join(clean_lines)\n",
        "\n",
        "                if clean_code.strip():\n",
        "                    # Извлечение импортов\n",
        "                    imports = self.code_analyzer.extract_imports(clean_code)\n",
        "                    all_imports.extend(imports)\n",
        "\n",
        "                    # Извлечение функций и классов\n",
        "                    code_elements = self.code_analyzer.extract_functions_and_classes(clean_code)\n",
        "                    all_code_elements['functions'].extend(code_elements['functions'])\n",
        "                    all_code_elements['classes'].extend(code_elements['classes'])\n",
        "\n",
        "        return list(set(all_imports)), all_code_elements\n",
        "\n",
        "    def process_notebook(self, notebook_data: Dict, notebook_info: Dict) -> Dict:\n",
        "        \"\"\"Обработка одного ноутбука\"\"\"\n",
        "        try:\n",
        "            self.log_handler.log(f\"Обработка ноутбука: {notebook_info['name']}\")\n",
        "\n",
        "            cells = notebook_data.get('cells', [])\n",
        "\n",
        "            # Извлечение данных\n",
        "            headers = self.extract_headers(cells)\n",
        "            conclusion = self.extract_conclusion(cells)\n",
        "            imports, code_elements = self.extract_code_elements(cells)\n",
        "\n",
        "            # Формирование списка функций и классов\n",
        "            functions_and_classes = []\n",
        "            for func in code_elements['functions']:\n",
        "                functions_and_classes.append(f\"Функция: {func['name']}\")\n",
        "            for cls in code_elements['classes']:\n",
        "                functions_and_classes.append(f\"Класс: {cls['name']}\")\n",
        "\n",
        "            result = {\n",
        "                'ссылка': notebook_info['link'],\n",
        "                'название': notebook_info['name'],\n",
        "                'заголовки': '; '.join(headers) if headers else 'нет заголовков',\n",
        "                'библиотеки': ', '.join(imports) if imports else 'нет импортов',\n",
        "                'классы и функции': '; '.join(functions_and_classes) if functions_and_classes else 'нет функций',\n",
        "                'описание': '',  # Будет заполнено LLM\n",
        "                'итог': conclusion,\n",
        "                'code_elements': code_elements  # Для передачи в LLM\n",
        "            }\n",
        "\n",
        "            self.log_handler.log(f\"Ноутбук {notebook_info['name']} обработан успешно\")\n",
        "            return result\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка обработки ноутбука {notebook_info['name']}: {str(e)}\", \"ERROR\")\n",
        "            return None\n",
        "\n",
        "# МОДУЛЬ РАБОТЫ С LLM\n",
        "\n",
        "class LLMProcessor:\n",
        "    \"\"\"Процессор для работы с языковой моделью\"\"\"\n",
        "\n",
        "    def __init__(self, api_key: str, endpoint: str, log_handler: LogHandler):\n",
        "        self.log_handler = log_handler\n",
        "        self.llm = ChatOpenAI(\n",
        "            openai_api_key=api_key,\n",
        "            openai_api_base=endpoint,\n",
        "            temperature=0.3,\n",
        "            model_name=\"gpt-4.1-nano\"\n",
        "        )\n",
        "        self.encoding = tiktoken.get_encoding(\"cl100k_base\")\n",
        "\n",
        "    def count_tokens(self, text: str) -> int:\n",
        "        \"\"\"Подсчет токенов в тексте\"\"\"\n",
        "        return len(self.encoding.encode(text))\n",
        "\n",
        "    def describe_code_element(self, element: Dict) -> str:\n",
        "        \"\"\"Получение описания элемента кода от LLM\"\"\"\n",
        "        try:\n",
        "            element_type = element.get('type', 'function')\n",
        "            element_name = element.get('name', 'unknown')\n",
        "            element_code = element.get('code', '')\n",
        "\n",
        "            prompt = f\"\"\"\n",
        "Проанализируй следующий код {element_type} '{element_name}' и опиши его в формате:\n",
        "\n",
        "{element_name}\n",
        "Логическая задача\n",
        "Краткое описание способа выполнения задачи\n",
        "\n",
        "Код:\n",
        "python\n",
        "{element_code}\n",
        "\n",
        "Ответ должен быть структурированным и кратким.\n",
        "\"\"\"\n",
        "\n",
        "            response = self.llm.invoke(prompt)\n",
        "            self.log_handler.log(f\"Получено описание для {element_type} {element_name}\")\n",
        "\n",
        "            return response.content.strip()\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка получения описания от LLM: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка описания {element.get('name', 'unknown')}\"\n",
        "\n",
        "    def describe_class_with_methods(self, class_element: Dict) -> str:\n",
        "        \"\"\"Получение описания класса с методами\"\"\"\n",
        "        try:\n",
        "            class_name = class_element.get('name', 'unknown')\n",
        "            methods = class_element.get('methods', [])\n",
        "\n",
        "            # Сначала получаем описания методов\n",
        "            method_descriptions = []\n",
        "            for method in methods:\n",
        "                method_desc = self.describe_code_element(method)\n",
        "                method_descriptions.append(method_desc)\n",
        "\n",
        "            # Затем описываем весь класс\n",
        "            methods_summary = '\\n'.join([f\"- {method['name']}\" for method in methods])\n",
        "\n",
        "            prompt = f\"\"\"\n",
        "Проанализируй класс '{class_name}' с методами и опиши его в формате:\n",
        "\n",
        "{class_name}\n",
        "Логическая задача\n",
        "Краткое описание способа выполнения задачи\n",
        "\n",
        "Методы класса:\n",
        "{methods_summary}\n",
        "\n",
        "Описания методов:\n",
        "{chr(10).join(method_descriptions)}\n",
        "\n",
        "Дай общее описание класса и его назначения.\n",
        "\"\"\"\n",
        "\n",
        "            response = self.llm.invoke(prompt)\n",
        "            self.log_handler.log(f\"Получено описание для класса {class_name}\")\n",
        "\n",
        "            return response.content.strip()\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка получения описания класса от LLM: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка описания класса {class_element.get('name', 'unknown')}\"\n",
        "\n",
        "    def process_notebook_descriptions(self, notebook_data: Dict) -> str:\n",
        "        \"\"\"Обработка всех элементов кода в ноутбуке\"\"\"\n",
        "        try:\n",
        "            code_elements = notebook_data.get('code_elements', {'functions': [], 'classes': []})\n",
        "            descriptions = []\n",
        "\n",
        "            # Обработка функций\n",
        "            for function in code_elements['functions']:\n",
        "                desc = self.describe_code_element(function)\n",
        "                descriptions.append(desc)\n",
        "\n",
        "            # Обработка классов\n",
        "            for class_element in code_elements['classes']:\n",
        "                desc = self.describe_class_with_methods(class_element)\n",
        "                descriptions.append(desc)\n",
        "\n",
        "            return '\\n\\n'.join(descriptions) if descriptions else 'Нет описаний'\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка обработки описаний: {str(e)}\", \"ERROR\")\n",
        "            return 'Ошибка обработки описаний'\n",
        "\n",
        "# МОДУЛЬ РАБОТЫ С ВЕКТОРНОЙ БАЗОЙ\n",
        "\n",
        "class ChromaManager:\n",
        "    \"\"\"Менеджер для работы с векторной базой Chroma\"\"\"\n",
        "\n",
        "    def __init__(self, api_key: str, endpoint: str, log_handler: LogHandler):\n",
        "        self.log_handler = log_handler\n",
        "\n",
        "        # ИЗМЕНЕНО: добавлен endpoint для embeddings\n",
        "        self.embeddings = OpenAIEmbeddings(\n",
        "            openai_api_key=api_key,\n",
        "            openai_api_base=endpoint,\n",
        "            model=\"text-embedding-3-small\"  # ИЗМЕНЕНО: используем text-embedding-3-small\n",
        "        )\n",
        "\n",
        "        self.vectorstore = None\n",
        "        self.qa_chain = None\n",
        "        self.api_key = api_key\n",
        "        self.endpoint = endpoint\n",
        "\n",
        "        # ИЗМЕНЕНО: используем cl100k_base токенизатор\n",
        "        self.encoding = tiktoken.get_encoding(\"cl100k_base\")\n",
        "\n",
        "    def create_vectorstore(self, df: pd.DataFrame) -> bool:\n",
        "        \"\"\"Создание векторной базы из датафрейма\"\"\"\n",
        "        try:\n",
        "            self.log_handler.log(\"Создание векторной базы Chroma\")\n",
        "\n",
        "            documents = []\n",
        "            metadatas = []\n",
        "\n",
        "            for _, row in df.iterrows():\n",
        "                # Документы для Chroma (текстовые данные)\n",
        "                doc_content = f\"\"\"\n",
        "Название: {row['название']}\n",
        "Заголовки: {row['заголовки']}\n",
        "Описание: {row['описание']}\n",
        "Итог: {row['итог']}\n",
        "\"\"\"\n",
        "\n",
        "                # Метаданные для Chroma\n",
        "                metadata = {\n",
        "                    'ссылка': row['ссылка'],\n",
        "                    'библиотеки': row['библиотеки'],\n",
        "                    'классы и функции': row['классы и функции']\n",
        "                }\n",
        "\n",
        "                documents.append(Document(page_content=doc_content, metadata=metadata))\n",
        "\n",
        "            # Создание векторной базы\n",
        "            self.vectorstore = Chroma.from_documents(\n",
        "                documents=documents,\n",
        "                embedding=self.embeddings,\n",
        "                persist_directory=\"./chroma_db\"\n",
        "            )\n",
        "\n",
        "            # Исоздание QA цепочки с ChatOpenAI\n",
        "            self.qa_chain = RetrievalQA.from_chain_type(\n",
        "                llm=ChatOpenAI(\n",
        "                    openai_api_key=self.api_key,\n",
        "                    openai_api_base=self.endpoint,\n",
        "                    temperature=0.3,\n",
        "                    model_name=\"gpt-4.1-nano\"\n",
        "                ),\n",
        "                chain_type=\"stuff\",\n",
        "                retriever=self.vectorstore.as_retriever(search_kwargs={\"k\": 3}),\n",
        "                return_source_documents=True\n",
        "            )\n",
        "\n",
        "            self.log_handler.log(f\"Векторная база создана с {len(documents)} документами\")\n",
        "            return True\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка создания векторной базы: {str(e)}\", \"ERROR\")\n",
        "            return False\n",
        "\n",
        "    def query(self, question: str) -> Tuple[str, int, List[str]]:\n",
        "        \"\"\"Запрос к векторной базе\"\"\"\n",
        "        try:\n",
        "            if not self.qa_chain:\n",
        "                return \"Векторная база не создана\", 0, []\n",
        "\n",
        "            self.log_handler.log(f\"Обработка запроса: {question}\")\n",
        "\n",
        "            # Подсчет токенов в запросе\n",
        "            input_tokens = len(self.encoding.encode(question))\n",
        "\n",
        "            # Выполнение запроса\n",
        "            result = self.qa_chain({\"query\": question})\n",
        "\n",
        "            # Подсчет токенов в ответе\n",
        "            output_tokens = len(self.encoding.encode(result['result']))\n",
        "            total_tokens = input_tokens + output_tokens\n",
        "\n",
        "            # Извлечение ссылок из источников\n",
        "            links = []\n",
        "            for doc in result.get('source_documents', []):\n",
        "                link = doc.metadata.get('ссылка')\n",
        "                if link and link not in links:\n",
        "                    links.append(link)\n",
        "\n",
        "            self.log_handler.log(f\"Запрос обработан. Использовано токенов: {total_tokens}\")\n",
        "\n",
        "            return result['result'], total_tokens, links\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка обработки запроса: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка: {str(e)}\", 0, []\n",
        "\n",
        "# ГЛАВНЫЙ КЛАСС ПРИЛОЖЕНИЯ\n",
        "\n",
        "class NotebookAssistant:\n",
        "    \"\"\"Главный класс ассистента обработки ноутбуков\"\"\"\n",
        "\n",
        "    def __init__(self):\n",
        "        self.log_handler = LogHandler()\n",
        "        self.colab_manager = ColabNotebookManager(self.log_handler)\n",
        "        self.notebook_processor = NotebookProcessor(self.log_handler)\n",
        "        self.llm_processor = None\n",
        "        self.chroma_manager = None\n",
        "        self.df = None\n",
        "        self.api_key = None\n",
        "        self.endpoint = None\n",
        "\n",
        "    def set_api_key(self, api_key: str, endpoint: str) -> str:\n",
        "        \"\"\"Установка API ключа и endpoint OpenAI\"\"\"\n",
        "        try:\n",
        "            self.api_key = api_key\n",
        "            self.endpoint = endpoint\n",
        "            self.llm_processor = LLMProcessor(api_key, endpoint, self.log_handler)\n",
        "            self.chroma_manager = ChromaManager(api_key, endpoint, self.log_handler)\n",
        "            self.log_handler.log(\"API ключ и endpoint установлены успешно\")\n",
        "            return \"API ключ и endpoint установлены успешно\"\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка установки API ключа: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка: {str(e)}\"\n",
        "\n",
        "    def get_data(self) -> Tuple[str, str]:\n",
        "        \"\"\"Получение и обработка данных из ноутбуков\"\"\"\n",
        "        try:\n",
        "            if not self.api_key:\n",
        "                return \"Сначала установите API ключ OpenAI\", self.log_handler.get_logs()\n",
        "\n",
        "            self.log_handler.clear_logs()\n",
        "            self.log_handler.log(\"Начало обработки ноутбуков\")\n",
        "\n",
        "            # Аутентификация\n",
        "            if not self.colab_manager.authenticate():\n",
        "                return \"Ошибка аутентификации\", self.log_handler.get_logs()\n",
        "\n",
        "            # Получение ноутбуков\n",
        "            notebooks = self.colab_manager.get_notebooks()\n",
        "            if not notebooks:\n",
        "                return \"Подходящие ноутбуки не найдены\", self.log_handler.get_logs()\n",
        "\n",
        "            # Обработка ноутбуков\n",
        "            processed_data = []\n",
        "            for notebook in notebooks:\n",
        "                self.log_handler.log(f\"Загрузка ноутбука: {notebook['name']}\")\n",
        "\n",
        "                notebook_content = self.colab_manager.get_notebook_content(notebook['id'])\n",
        "                if notebook_content:\n",
        "                    processed_notebook = self.notebook_processor.process_notebook(\n",
        "                        notebook_content, notebook\n",
        "                    )\n",
        "\n",
        "                    if processed_notebook:\n",
        "                        # Получение описаний от LLM\n",
        "                        self.log_handler.log(f\"Получение описаний от LLM для: {notebook['name']}\")\n",
        "                        description = self.llm_processor.process_notebook_descriptions(processed_notebook)\n",
        "                        processed_notebook['описание'] = description\n",
        "\n",
        "                        # Удаляем временные данные\n",
        "                        del processed_notebook['code_elements']\n",
        "                        processed_data.append(processed_notebook)\n",
        "\n",
        "            # Создание датафрейма\n",
        "            self.df = pd.DataFrame(processed_data)\n",
        "\n",
        "            self.log_handler.log(f\"Обработка завершена. Создан датафрейм с {len(self.df)} записями\")\n",
        "\n",
        "            return f\"Успешно обработано {len(self.df)} ноутбуков\", self.log_handler.get_logs()\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Критическая ошибка: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка: {str(e)}\", self.log_handler.get_logs()\n",
        "\n",
        "    def download_dataframe(self) -> Tuple[str, Optional[str]]:\n",
        "        \"\"\"Скачивание датафрейма\"\"\"\n",
        "        try:\n",
        "            if self.df is None:\n",
        "                return \"Сначала получите данные\", None\n",
        "\n",
        "            filename = f\"notebooks_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\"\n",
        "            filepath = f\"/content/{filename}\"\n",
        "            self.df.to_csv(filepath, index=False, encoding='utf-8')\n",
        "\n",
        "            self.log_handler.log(f\"Датафрейм сохранен: {filename}\")\n",
        "            return f\"Файл {filename} готов к скачиванию\", filepath\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка скачивания: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка: {str(e)}\", None\n",
        "\n",
        "    def load_dataframe(self, file_path: str) -> str:\n",
        "        \"\"\"Загрузка датафрейма из файла\"\"\"\n",
        "        try:\n",
        "            if not file_path:\n",
        "                return \"Файл не выбран\"\n",
        "\n",
        "            self.df = pd.read_csv(file_path, encoding='utf-8')\n",
        "            self.log_handler.log(f\"Датафрейм загружен из {file_path}\")\n",
        "            return f\"Датафрейм загружен успешно. Записей: {len(self.df)}\"\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка загрузки датафрейма: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка: {str(e)}\"\n",
        "\n",
        "    def save_vectorstore(self) -> str:\n",
        "        \"\"\"Сохранение векторной базы\"\"\"\n",
        "        try:\n",
        "            if not self.chroma_manager or not self.chroma_manager.vectorstore:\n",
        "                return \"Векторная база не создана\"\n",
        "\n",
        "            # Chroma автоматически сохраняется в persist_directory\n",
        "            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n",
        "            backup_dir = f\"/content/chroma_backup_{timestamp}\"\n",
        "\n",
        "            import shutil\n",
        "            shutil.copytree(\"./chroma_db\", backup_dir)\n",
        "\n",
        "            self.log_handler.log(f\"Векторная база сохранена в {backup_dir}\")\n",
        "            return f\"База сохранена в {backup_dir}\"\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка сохранения базы: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка: {str(e)}\"\n",
        "\n",
        "    def load_vectorstore(self, backup_dir: str) -> str:\n",
        "        \"\"\"Загрузка векторной базы\"\"\"\n",
        "        try:\n",
        "            if not backup_dir:\n",
        "                return \"Папка не выбрана\"\n",
        "\n",
        "            if not self.chroma_manager:\n",
        "                return \"Сначала установите API ключ\"\n",
        "\n",
        "            # Удаляем старую базу если есть\n",
        "            if os.path.exists(\"./chroma_db\"):\n",
        "                shutil.rmtree(\"./chroma_db\")\n",
        "\n",
        "            # Копируем загруженную базу\n",
        "            shutil.copytree(backup_dir, \"./chroma_db\")\n",
        "\n",
        "            # Переинициализируем векторную базу\n",
        "            self.chroma_manager.vectorstore = Chroma(\n",
        "                persist_directory=\"./chroma_db\",\n",
        "                embedding_function=self.chroma_manager.embeddings\n",
        "            )\n",
        "\n",
        "            # Создание QA цепочки\n",
        "            from langchain_openai import ChatOpenAI\n",
        "            self.chroma_manager.qa_chain = RetrievalQA.from_chain_type(\n",
        "                llm=ChatOpenAI(\n",
        "                    openai_api_key=self.chroma_manager.api_key,\n",
        "                    openai_api_base=self.chroma_manager.endpoint,\n",
        "                    temperature=0.3,\n",
        "                    model_name=\"gpt-4.1-nano\"\n",
        "                ),\n",
        "                chain_type=\"stuff\",\n",
        "                retriever=self.chroma_manager.vectorstore.as_retriever(search_kwargs={\"k\": 3}),\n",
        "                return_source_documents=True\n",
        "            )\n",
        "\n",
        "            self.log_handler.log(f\"Векторная база загружена из {backup_dir}\")\n",
        "            return \"База загружена успешно\"\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка загрузки базы: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка: {str(e)}\"\n",
        "\n",
        "\n",
        "    def create_vectorstore(self) -> Tuple[str, str]:\n",
        "        \"\"\"Создание векторной базы\"\"\"\n",
        "        try:\n",
        "            if self.df is None:\n",
        "                return \"Сначала получите данные\", self.log_handler.get_logs()\n",
        "\n",
        "            if not self.chroma_manager:\n",
        "                return \"API ключ не установлен\", self.log_handler.get_logs()\n",
        "\n",
        "            success = self.chroma_manager.create_vectorstore(self.df)\n",
        "\n",
        "            if success:\n",
        "                return \"Векторная база создана успешно\", self.log_handler.get_logs()\n",
        "            else:\n",
        "                return \"Ошибка создания векторной базы\", self.log_handler.get_logs()\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка создания базы: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка: {str(e)}\", self.log_handler.get_logs()\n",
        "\n",
        "    def query_assistant(self, question: str) -> Tuple[str, str, str]:\n",
        "        \"\"\"Запрос к ассистенту\"\"\"\n",
        "        try:\n",
        "            if not self.chroma_manager or not self.chroma_manager.qa_chain:\n",
        "                return \"Векторная база не создана\", \"\", self.log_handler.get_logs()\n",
        "\n",
        "            answer, tokens, links = self.chroma_manager.query(question)\n",
        "\n",
        "            # Форматирование ответа\n",
        "            response = f\"{answer}\\n\\n\"\n",
        "            if links:\n",
        "                response += \"Ссылки на ноутбуки:\\n\"\n",
        "                for i, link in enumerate(links, 1):\n",
        "                    response += f\"{i}. {link}\\n\"\n",
        "\n",
        "            token_info = f\"Использовано токенов: {tokens}\"\n",
        "\n",
        "            return response, token_info, self.log_handler.get_logs()\n",
        "\n",
        "        except Exception as e:\n",
        "            self.log_handler.log(f\"Ошибка запроса: {str(e)}\", \"ERROR\")\n",
        "            return f\"Ошибка: {str(e)}\", \"\", self.log_handler.get_logs()\n",
        "\n",
        "# ИНТЕРФЕЙС GRADIO\n",
        "\n",
        "def create_interface():\n",
        "    \"\"\"Создание интерфейса Gradio\"\"\"\n",
        "\n",
        "    assistant = NotebookAssistant()\n",
        "\n",
        "    with gr.Blocks(title=\"Ассистент обработки ноутбуков\") as interface:\n",
        "        gr.Markdown(\"# 🤖 Ассистент обработки ноутбуков Google Colab\")\n",
        "        gr.Markdown(\"Анализирует ваши ноутбуки и создает векторную базу для поиска\")\n",
        "\n",
        "        with gr.Tab(\"⚙️ Настройка\"):\n",
        "            api_key_input = gr.Textbox(\n",
        "                label=\"OpenAI API Key\",\n",
        "                type=\"password\",\n",
        "                placeholder=\"sk-...\"\n",
        "            )\n",
        "            endpoint_input = gr.Textbox(\n",
        "                label=\"OpenAI Endpoint\",\n",
        "                placeholder=\"https://api.openai.com/v1\",\n",
        "                value=\"https://api.openai.com/v1\"\n",
        "            )\n",
        "            api_key_btn = gr.Button(\"Установить настройки\")\n",
        "            api_key_output = gr.Textbox(label=\"Статус\", interactive=False)\n",
        "\n",
        "            api_key_btn.click(\n",
        "                assistant.set_api_key,\n",
        "                inputs=[api_key_input, endpoint_input],\n",
        "                outputs=[api_key_output]\n",
        "            )\n",
        "\n",
        "        with gr.Tab(\"📊 Обработка данных\"):\n",
        "            with gr.Row():\n",
        "                get_data_btn = gr.Button(\"Получить данные\", variant=\"primary\")\n",
        "                create_db_btn = gr.Button(\"Создать базу\", variant=\"secondary\")\n",
        "\n",
        "            with gr.Row():\n",
        "                with gr.Column():\n",
        "                    gr.Markdown(\"### Датафрейм\")\n",
        "                    download_btn = gr.Button(\"Скачать датафрейм\")\n",
        "                    download_file = gr.File(label=\"Скачать файл\", visible=False)\n",
        "                    upload_df = gr.File(label=\"Загрузить датафрейм (.csv)\", file_types=[\".csv\"])\n",
        "                    load_df_btn = gr.Button(\"Загрузить датафрейм\")\n",
        "\n",
        "                with gr.Column():\n",
        "                    gr.Markdown(\"### Векторная база\")\n",
        "                    save_db_btn = gr.Button(\"Сохранить базу\")\n",
        "                    upload_db = gr.File(label=\"Загрузить базу (папка)\", file_count=\"directory\")\n",
        "                    load_db_btn = gr.Button(\"Загрузить базу\")\n",
        "\n",
        "            status_output = gr.Textbox(label=\"Статус операции\", interactive=False)\n",
        "            logs_output = gr.Textbox(\n",
        "                label=\"Логи выполнения\",\n",
        "                lines=10,\n",
        "                interactive=False\n",
        "            )\n",
        "\n",
        "            # Обработчики событий\n",
        "            get_data_btn.click(\n",
        "                assistant.get_data,\n",
        "                outputs=[status_output, logs_output]\n",
        "            )\n",
        "\n",
        "            def handle_download(assistant_ref):\n",
        "                status, filepath = assistant_ref.download_dataframe()\n",
        "                if filepath:\n",
        "                    return status, gr.update(value=filepath, visible=True)\n",
        "                return status, gr.update(visible=False)\n",
        "\n",
        "            download_btn.click(\n",
        "                lambda: handle_download(assistant),\n",
        "                outputs=[status_output, download_file]\n",
        "            )\n",
        "\n",
        "            load_df_btn.click(\n",
        "                lambda file: assistant.load_dataframe(file.name if file else \"\"),\n",
        "                inputs=[upload_df],\n",
        "                outputs=[status_output]\n",
        "            )\n",
        "\n",
        "            create_db_btn.click(\n",
        "                assistant.create_vectorstore,\n",
        "                outputs=[status_output, logs_output]\n",
        "            )\n",
        "\n",
        "            save_db_btn.click(\n",
        "                assistant.save_vectorstore,\n",
        "                outputs=[status_output]\n",
        "            )\n",
        "\n",
        "            load_db_btn.click(\n",
        "                lambda file: assistant.load_vectorstore(file.name if file else \"\"),\n",
        "                inputs=[upload_db],\n",
        "                outputs=[status_output]\n",
        "            )\n",
        "\n",
        "\n",
        "        with gr.Tab(\"🔍 Поиск\"):\n",
        "            question_input = gr.Textbox(\n",
        "                label=\"Ваш вопрос\",\n",
        "                placeholder=\"Например: Найди ноутбуки с обработкой данных\",\n",
        "                lines=2\n",
        "            )\n",
        "            search_btn = gr.Button(\"Найти\", variant=\"primary\")\n",
        "\n",
        "            answer_output = gr.Textbox(\n",
        "                label=\"Ответ\",\n",
        "                lines=10,\n",
        "                interactive=False\n",
        "            )\n",
        "            tokens_output = gr.Textbox(label=\"Использовано токенов\", interactive=False)\n",
        "            search_logs_output = gr.Textbox(\n",
        "                label=\"Логи поиска\",\n",
        "                lines=5,\n",
        "                interactive=False\n",
        "            )\n",
        "\n",
        "            search_btn.click(\n",
        "                assistant.query_assistant,\n",
        "                inputs=[question_input],\n",
        "                outputs=[answer_output, tokens_output, search_logs_output]\n",
        "            )\n",
        "\n",
        "    return interface\n",
        "\n",
        "# ЗАПУСК ПРИЛОЖЕНИЯ\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    # Создание и запуск интерфейса\n",
        "    interface = create_interface()\n",
        "    interface.launch(\n",
        "        share=True,\n",
        "        debug=True,\n",
        "        server_name=\"0.0.0.0\",\n",
        "        server_port=7860\n",
        "    )"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "toc_visible": true,
      "authorship_tag": "ABX9TyNHV9aH8qx+G5BXkyOkiFbM"
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}